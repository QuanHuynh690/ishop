{"ast":null,"code":"import { RequestSessionStatus, SessionStatus } from '@sentry/types';\nimport { dropUndefinedKeys, logger, uuid4 } from '@sentry/utils';\nimport { getCurrentHub } from './hub';\n/**\n * @inheritdoc\n */\n\nvar Session =\n/** @class */\nfunction () {\n  function Session(context) {\n    this.errors = 0;\n    this.sid = uuid4();\n    this.timestamp = Date.now();\n    this.started = Date.now();\n    this.duration = 0;\n    this.status = SessionStatus.Ok;\n    this.init = true;\n\n    if (context) {\n      this.update(context);\n    }\n  }\n  /** JSDoc */\n  // eslint-disable-next-line complexity\n\n\n  Session.prototype.update = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    if (context.user) {\n      if (context.user.ip_address) {\n        this.ipAddress = context.user.ip_address;\n      }\n\n      if (!context.did) {\n        this.did = context.user.id || context.user.email || context.user.username;\n      }\n    }\n\n    this.timestamp = context.timestamp || Date.now();\n\n    if (context.sid) {\n      // Good enough uuid validation. — Kamil\n      this.sid = context.sid.length === 32 ? context.sid : uuid4();\n    }\n\n    if (context.init !== undefined) {\n      this.init = context.init;\n    }\n\n    if (context.did) {\n      this.did = \"\" + context.did;\n    }\n\n    if (typeof context.started === 'number') {\n      this.started = context.started;\n    }\n\n    if (typeof context.duration === 'number') {\n      this.duration = context.duration;\n    } else {\n      this.duration = this.timestamp - this.started;\n    }\n\n    if (context.release) {\n      this.release = context.release;\n    }\n\n    if (context.environment) {\n      this.environment = context.environment;\n    }\n\n    if (context.ipAddress) {\n      this.ipAddress = context.ipAddress;\n    }\n\n    if (context.userAgent) {\n      this.userAgent = context.userAgent;\n    }\n\n    if (typeof context.errors === 'number') {\n      this.errors = context.errors;\n    }\n\n    if (context.status) {\n      this.status = context.status;\n    }\n  };\n  /** JSDoc */\n\n\n  Session.prototype.close = function (status) {\n    if (status) {\n      this.update({\n        status: status\n      });\n    } else if (this.status === SessionStatus.Ok) {\n      this.update({\n        status: SessionStatus.Exited\n      });\n    } else {\n      this.update();\n    }\n  };\n  /** JSDoc */\n\n\n  Session.prototype.toJSON = function () {\n    return dropUndefinedKeys({\n      sid: \"\" + this.sid,\n      init: this.init,\n      started: new Date(this.started).toISOString(),\n      timestamp: new Date(this.timestamp).toISOString(),\n      status: this.status,\n      errors: this.errors,\n      did: typeof this.did === 'number' || typeof this.did === 'string' ? \"\" + this.did : undefined,\n      duration: this.duration,\n      attrs: dropUndefinedKeys({\n        release: this.release,\n        environment: this.environment,\n        ip_address: this.ipAddress,\n        user_agent: this.userAgent\n      })\n    });\n  };\n\n  return Session;\n}();\n\nexport { Session };\n/**\n * @inheritdoc\n */\n\nvar SessionFlusher =\n/** @class */\nfunction () {\n  function SessionFlusher(transport, attrs) {\n    var _this = this;\n\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n    this._transport = transport; // Call to setInterval, so that flush is called every 60 seconds\n\n    this._intervalId = setInterval(function () {\n      return _this.flush();\n    }, this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n  /** Sends session aggregates to Transport */\n\n\n  SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {\n    if (!this._transport.sendSession) {\n      logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n\n    this._transport.sendSession(sessionAggregates).then(null, function (reason) {\n      logger.error(\"Error while sending session: \" + reason);\n    });\n  };\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n\n\n  SessionFlusher.prototype.flush = function () {\n    var sessionAggregates = this.getSessionAggregates();\n\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  };\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n\n\n  SessionFlusher.prototype.getSessionAggregates = function () {\n    var _this = this;\n\n    var aggregates = Object.keys(this._pendingAggregates).map(function (key) {\n      return _this._pendingAggregates[parseInt(key)];\n    });\n    var sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates: aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  };\n  /** JSDoc */\n\n\n  SessionFlusher.prototype.close = function () {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  };\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n\n\n  SessionFlusher.prototype.incrementSessionStatusCount = function () {\n    var _a, _b;\n\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var scope = getCurrentHub().getScope();\n    var requestSession = (_a = scope) === null || _a === void 0 ? void 0 : _a.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date()); // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n\n\n      (_b = scope) === null || _b === void 0 ? void 0 : _b.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  };\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n\n\n  SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {}; // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n\n    var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case RequestSessionStatus.Errored:\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n\n      case RequestSessionStatus.Ok:\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n\n      case RequestSessionStatus.Crashed:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  };\n\n  return SessionFlusher;\n}();\n\nexport { SessionFlusher };","map":{"version":3,"sources":["../src/session.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  Session as SessionInterface,\n  SessionAggregates,\n  SessionContext,\n  SessionFlusherLike,\n  SessionStatus,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger, uuid4 } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\n\n/**\n * @inheritdoc\n */\nexport class Session implements SessionInterface {\n  public userAgent?: string;\n  public errors: number = 0;\n  public release?: string;\n  public sid: string = uuid4();\n  public did?: string;\n  public timestamp: number = Date.now();\n  public started: number = Date.now();\n  public duration: number = 0;\n  public status: SessionStatus = SessionStatus.Ok;\n  public environment?: string;\n  public ipAddress?: string;\n  public init: boolean = true;\n\n  public constructor(context?: Omit<SessionContext, 'started' | 'status'>) {\n    if (context) {\n      this.update(context);\n    }\n  }\n\n  /** JSDoc */\n  // eslint-disable-next-line complexity\n  public update(context: SessionContext = {}): void {\n    if (context.user) {\n      if (context.user.ip_address) {\n        this.ipAddress = context.user.ip_address;\n      }\n\n      if (!context.did) {\n        this.did = context.user.id || context.user.email || context.user.username;\n      }\n    }\n\n    this.timestamp = context.timestamp || Date.now();\n\n    if (context.sid) {\n      // Good enough uuid validation. — Kamil\n      this.sid = context.sid.length === 32 ? context.sid : uuid4();\n    }\n    if (context.init !== undefined) {\n      this.init = context.init;\n    }\n    if (context.did) {\n      this.did = `${context.did}`;\n    }\n    if (typeof context.started === 'number') {\n      this.started = context.started;\n    }\n    if (typeof context.duration === 'number') {\n      this.duration = context.duration;\n    } else {\n      this.duration = this.timestamp - this.started;\n    }\n    if (context.release) {\n      this.release = context.release;\n    }\n    if (context.environment) {\n      this.environment = context.environment;\n    }\n    if (context.ipAddress) {\n      this.ipAddress = context.ipAddress;\n    }\n    if (context.userAgent) {\n      this.userAgent = context.userAgent;\n    }\n    if (typeof context.errors === 'number') {\n      this.errors = context.errors;\n    }\n    if (context.status) {\n      this.status = context.status;\n    }\n  }\n\n  /** JSDoc */\n  public close(status?: Exclude<SessionStatus, SessionStatus.Ok>): void {\n    if (status) {\n      this.update({ status });\n    } else if (this.status === SessionStatus.Ok) {\n      this.update({ status: SessionStatus.Exited });\n    } else {\n      this.update();\n    }\n  }\n\n  /** JSDoc */\n  public toJSON(): {\n    init: boolean;\n    sid: string;\n    did?: string;\n    timestamp: string;\n    started: string;\n    duration: number;\n    status: SessionStatus;\n    errors: number;\n    attrs?: {\n      release?: string;\n      environment?: string;\n      user_agent?: string;\n      ip_address?: string;\n    };\n  } {\n    return dropUndefinedKeys({\n      sid: `${this.sid}`,\n      init: this.init,\n      started: new Date(this.started).toISOString(),\n      timestamp: new Date(this.timestamp).toISOString(),\n      status: this.status,\n      errors: this.errors,\n      did: typeof this.did === 'number' || typeof this.did === 'string' ? `${this.did}` : undefined,\n      duration: this.duration,\n      attrs: dropUndefinedKeys({\n        release: this.release,\n        environment: this.environment,\n        ip_address: this.ipAddress,\n        user_agent: this.userAgent,\n      }),\n    });\n  }\n}\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    this._transport.sendSession(sessionAggregates).then(null, reason => {\n      logger.error(`Error while sending session: ${reason}`);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope?.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope?.setRequestSession(undefined);\n\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case RequestSessionStatus.Errored:\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case RequestSessionStatus.Ok:\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      case RequestSessionStatus.Crashed:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}